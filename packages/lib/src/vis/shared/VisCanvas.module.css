.canvasWrapper {
  flex: 1 1 0%;
  overflow: hidden; /* prevent overflow when resizing */
  position: relative; /* for axis system */
  z-index: 0; /* stacking context for anything rendered above the canvas (axis grid, SVG scene, floating toolbar, tooltip, etc.) */

  /*
   * Stacking order, from furthest to closest:
   * 1. WebGL canvas
   * 2. axis system (i.e. most notably the grid)
   * 3. SVG overlay
   * 4. anything rendered via `Html` (`Overlay`, `Annotation`, etc.) â€” by default with no z-index, which is equivalent to `z-index: 0`
   * 5. tooltip + guides
   * 6. floating toolbar
   */
  --h5w-zi-canvas: -3000;
  --h5w-zi-axisSystem: -2000;
  --h5w-zi-svgOverlay: -1000;
  --h5w-zi-tooltip: 1000;
  --h5w-zi-floatingToolbar: 2000;
}

.r3fRoot {
  /* `r3fRoot` is implicitely stacked at `z-index: 0`, so it intercepts events before they reach the canvas.
   * We can't stack it explicitly without creating a new stacking context, which breaks the stacking order
   * (the axis system ends up either behind or in front of everything else, neither of which is acceptable).
   * So we disable pointer events and restore them only on the `canvas` and on specific interactive elements,
   * like the floating toolbar. */
  pointer-events: none;
  background-color: var(--h5w-canvas--bgColor, transparent);
}

.r3fRoot > canvas {
  position: relative;
  z-index: var(--h5w-zi-canvas);
  pointer-events: auto;
}

.svgOverlay {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  z-index: var(--h5w-zi-svgOverlay);
}

.floatingToolbar {
  position: absolute;
  right: 0;
  bottom: 0;
  display: flex;
  z-index: var(--h5w-zi-floatingToolbar);
  pointer-events: auto;
}
